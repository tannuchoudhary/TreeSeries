# Postorder using iteration(using 2 stacks)


## Steps:
* Take 2 stack, st1 and st2
* Push root in st1
* pop the top element of st1 and push it in st2
* after pushing something in st2, find out if it has left and right, if it has then push the left and right in the st1
* now again pop the top element of stack and push it in st2, and find out if it has left and right, if it has then push the left and right in the st1
* continue this process until st1 will become empty

![Screenshot from 2021-10-10 02-17-05](https://user-images.githubusercontent.com/42698268/136673386-30384185-ecfe-4288-a21d-04526d51e00b.png)

```cpp
//iterative - using two stacks

class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> postorder;
        if(root == NULL) return postorder;
        
        stack<TreeNode*> st1, st2;
        
        st1.push(root);
        while(!st1.empty()){
            TreeNode* node = st1.top();
            st1.pop();
            st2.push(node);
            
            if(node->left) st1.push(node->left);
            if(node->right) st1.push(node->right);
        }
        
        while(!st2.empty()){
            postorder.push_back(st2.top()->val);
            st2.pop();
         }
        return postorder;
    }
};

```

# Postorder using iteration(using 1 stack)

## Steps
* create a stack
* Push all the left into the stack
* check if the top of the stack contains right
* if not then just push the top into postorder(answer)
    * if the pushed element was right of someone, and that right( i.e root of the current pushed element) is in top of the stack then push that into postorder, and do this until the temp is right of top of the stack, we are doin this because first we pushed left into the postorder then we are checking whether the pushed element was left or right, if it is right then now it is the turn of root to be pushed of

* if it contains right, then push all of them into the stack

basically, we are moving to the left and push everything in stack, and now push the top of the stack  in answer only if it does not contains right, if contains right then push the right subtree in stack, now after psuhing anything in asnwer, check if the pushed element is right element of top of the stack, if yes then push the top of the stack into the answer and pop it from stack, because this is the root element which should always come after right and that is what we are doing.

```cpp
//iterative - using one stack

class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> postorder;
        if(root == NULL) return postorder;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while(cur!=NULL || !st.empty()){
            if(cur!=NULL){
                st.push(cur);
                cur = cur->left;
            }
            
            else{
                TreeNode* temp = st.top()->right;
                if(temp == NULL){
                    temp = st.top();
                    st.pop();
                    postorder.push_back(temp->val);
                    
                    while(!st.empty() && temp == st.top()->right){
                        temp = st.top();
                        st.pop();
                        postorder.push_back(temp->val);
                    }
                }
                
                else cur = temp;
            }
            
        }
        return postorder;
    }
};


```
```dry run to understand this, atleast on 2-3 trees```
## Time complexity and space complexity
* T.C will be ```O(2N)``` (worst case in skew tree
* S.C will be ```O(N)```




















